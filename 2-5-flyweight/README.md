# UML 类图
```
          +-------------------+
          |     Flyweight     |  <<interface>>
          +-------------------+
          | + operation(extrinsicState: string) const |
          +-------------------+
                    ^
                    |
          +-------------------------+
          |   ConcreteFlyweight     |
          +-------------------------+
          | - intrinsicState: string|
          +-------------------------+
          | + operation(extrinsicState: string) const |
          +-------------------------+

          +-------------------------+
          |    FlyweightFactory     |
          +-------------------------+
          | - flyweights:           |
          |   unordered_map<string, shared_ptr<Flyweight>> |
          +-------------------------+
          | + getFlyweight(key: string): shared_ptr<Flyweight>|
          | + listFlyweights() const                             |
          +-------------------------+

```

## 说明：

- **Flyweight（享元接口）**：定义了享元对象的公共操作接口。
- **ConcreteFlyweight（具体享元类）**：实现了享元接口，并包含一个不可变的内部状态（intrinsicState），该状态在对象创建时确定，可被多个客户端共享。
- **FlyweightFactory（享元工厂）**：负责管理享元对象，通过 key 查找或创建享元对象，确保共享相同内蕴状态的对象只存在一个实例。

# 编译方法
```
g++ -std=c++11 -Wall -o flyweight flyweight.cpp
```

# 实用场景与实际价值
## 实用场景
- 大量相似对象的场景
当系统中需要创建大量相似的对象（例如图形编辑器中的图形对象、文本处理中的字符对象）时，通过共享对象可以显著减少内存占用。

- 资源消耗高的对象
如果对象的创建和销毁开销较大，且内部状态不经常变化，享元模式能够复用已创建的对象，减少频繁的内存分配和垃圾回收，提高系统性能。

- 缓存机制
在一些需要缓存大量数据或对象的场景下，通过享元模式来存储共享对象，可以避免重复加载或生成相同的数据，提高系统响应速度和资源利用率。

## 实际价值
- 减少内存占用
通过共享相同的内部状态，实现对象的复用，特别适用于对象数量非常庞大的系统，能显著降低内存消耗。

- 提高性能
复用已有对象可以减少对象的频繁创建和销毁，从而提高系统整体的性能和响应速度。

- 符合开闭原则
享元模式通过将对象的内部状态与外部状态分离，使得对象的共享和管理更为集中，便于扩展和维护。