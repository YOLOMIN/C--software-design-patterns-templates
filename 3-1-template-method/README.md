# UML类图
```
          +--------------------------+
          |     AbstractClass        |<<abstract>>
          +--------------------------+
          | + templateMethod() const |
          | + step1() const          |  // 固定实现
          | + step2() const = 0      |  // 抽象方法
          | + step3() const          |  // 固定实现
          | + step4() const          |  // 钩子方法（默认空实现）
          +--------------------------+
                      ^
                      |
                      |
          +--------------------------+
          |     ConcreteClass        |
          +--------------------------+
          | + step2() const override |
          | + step4() const override |
          +--------------------------+

```

## 图中说明：

- **AbstractClass**：抽象类，定义了模板方法 templateMethod()，其中依次调用 step1()、step2()、step3() 和 step4()。其中 step1() 和 step3() 为固定步骤；step2() 为纯虚函数，必须由子类实现；step4() 为钩子方法，子类可以根据需要重写。
- **ConcreteClass**：具体子类，实现了 step2() 和 step4()，以提供定制行为。

# 编译方法
```
g++ -std=c++11 -Wall -o template-method template-method.cpp
```

# 实际应用场景与使用价值
## 实际应用场景：

### 数据处理流程
当一个数据处理流程有固定的步骤（如数据预处理、数据处理、结果输出），但某些步骤需要根据业务需求定制时，可以使用模板方法模式将固定流程抽象出来，而将可变部分留给子类实现。

### 用户界面绘制
在 GUI 应用中，绘制界面通常包含加载资源、布局计算和绘制输出等固定步骤，不同主题的界面只需重写部分步骤即可，模板方法模式可以帮助统一整体绘制流程。

### 游戏逻辑
游戏中角色行为的执行通常遵循固定流程（如准备、执行、后处理），而具体角色的行为细节不同，可通过模板方法模式实现统一控制和定制扩展。

## 使用价值：

### 提高代码复用性
模板方法模式将公共的算法骨架放在基类中，避免重复编写相同逻辑，子类只需实现可变部分。

### 遵循开闭原则
当需要扩展新的行为时，只需要创建新的子类并重写部分步骤，而无需修改基类代码。

### 控制反转
模板方法模式将算法流程的控制权交给基类，子类只负责实现具体细节，从而实现反转控制，使得算法更加灵活可扩展