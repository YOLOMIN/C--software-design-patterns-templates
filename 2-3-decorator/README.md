# UML类图
```
                      +-------------------+
                      |    Component      |
                      +-------------------+
                      | + operation()     |
                      |   const = 0       |
                      +-------------------+
                              ^ 
                              |
       +----------------------+----------------------+
       |                                             |
+----------------------+                     +----------------------+
| ConcreteComponent    |                     |     Decorator        |
+----------------------+                     +----------------------+
| + operation()        |                     | - component:         |
+----------------------+                     |   unique_ptr<Component> |
                                             | + operation()        |
                                             +----------------------+
                                                      ^
                                                      |
                              +-----------------------+-----------------------+
                              |                                               |
                  +-------------------------+                     +-------------------------+
                  | ConcreteDecoratorA      |                     | ConcreteDecoratorB      |
                  +-------------------------+                     +-------------------------+
                  | + operation()           |                     | + operation()           |
                  +-------------------------+                     +-------------------------+
```

## 说明
- **Component**：抽象组件类，定义了一个纯虚函数 operation()。
- **ConcreteComponent**：具体组件，实现了 Component 接口，提供基础功能。
- **Decorator**：抽象装饰器，同样继承自 Component，内部持有一个 Component 对象，用于委托调用。
- **ConcreteDecoratorA / ConcreteDecoratorB**：具体装饰器，实现了对 operation() 方法的扩展，分别在调用基础组件操作后（或前后）增加新的行为。

# 编译
```
g++ -std=c++17 -Wall -o decorator decorator.cpp

```

# 应用价值

装饰器模式（Decorator Pattern）是一种结构型设计模式，允许在不修改现有类的情况下，动态地为对象添加新的功能。它通过创建一个包含原对象引用的装饰器对象，动态地提供额外的行为，比继承更加灵活。 citeturn0search3

**实际应用场景：**

1. **动态扩展对象功能：** 当需要为某个对象添加新功能，而不希望影响其他对象或修改类定义时，装饰器模式提供了一种灵活的解决方案。 citeturn0search6

2. **替代类继承：** 在需要扩展类功能时，直接继承可能导致大量子类的产生，增加系统复杂性。装饰器模式通过组合的方式，避免了这种情况的发生。 citeturn0search5

3. **遵循开闭原则：** 装饰器模式遵循开闭原则，可以在不修改原有代码的基础上增加新的功能。 citeturn0search6

**实际应用案例：**

- **Java I/O 库：** Java 的 I/O 库广泛使用了装饰器模式。例如，`BufferedReader` 和 `BufferedWriter` 类为基础的 `Reader` 和 `Writer` 类添加了缓冲功能，增强了读写性能。 citeturn0search10

- **图形界面组件：** 在图形界面开发中，装饰器模式常用于为界面组件添加滚动条、边框等功能，而无需修改原有组件的代码。 citeturn0search10

**优点：**

- **灵活性：** 装饰器模式允许通过不同的装饰类及其排列组合，实现多样化的功能扩展。 citeturn0search6

- **遵循开闭原则：** 可以在不修改原有代码的基础上增加新的功能，增强系统的可扩展性。 citeturn0search6

**缺点：**

- **增加系统复杂性：** 过度使用装饰器模式可能导致系统中增加大量的小对象，增加系统的复杂性。 citeturn0search5

- **调试困难：** 多次装饰的对象在调试时需要逐级排查，可能会增加调试的难度。 citeturn0search5

总的来说，装饰器模式在需要动态扩展对象功能、遵循开闭原则以及避免类继承导致的复杂性时，提供了一种灵活且有效的解决方案。 