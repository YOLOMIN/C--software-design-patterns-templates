# UML类图
!](image.png)

- State：抽象状态接口，定义了 handle(Context* context) 方法，用于处理请求并可能进行状态切换。

- ConcreteStateA 与 ConcreteStateB：具体状态类，实现了 State 接口，在处理请求时根据业务逻辑切换状态。

- Context：环境类，维护当前状态（使用 unique_ptr<State> 管理），提供 request() 方法委托给当前状态处理，并允许状态切换。

# 编译方法
```
g++ -std=c++11 -Wall -o state_pattern state_pattern.cpp
```

# 实际应用场景与使用价值
## 实际应用场景：

- 用户界面状态管理\
在 GUI 应用中，一个组件（例如按钮或菜单）的行为可能根据状态（启用、禁用、悬停等）不同而变化。使用状态模式可以将状态处理逻辑封装在不同状态类中，使得代码清晰且易于扩展。

- 游戏角色状态\
游戏中角色可能存在多种状态（如闲置、行走、攻击、防御等），每个状态对应不同的行为逻辑。状态模式可以使角色在状态切换时自动改变行为，简化游戏逻辑处理。

- 网络连接管理\
网络连接对象可以有不同状态（如连接中、已连接、断开等），状态模式可以根据当前状态执行相应的操作，并实现状态之间的平滑切换。

## 使用价值：

- 降低复杂性\
将状态相关的行为封装到独立的状态类中，避免在一个类中出现大量的条件判断，使代码更加模块化和易于维护。

- 符合开闭原则\
当需要增加新的状态时，只需添加新的具体状态类，而无需修改环境类或其他状态类的代码，实现系统的扩展而不影响稳定性。

- 动态行为切换\
状态模式使对象能够根据内部状态的变化动态改变行为，提高了系统的灵活性和响应能力。