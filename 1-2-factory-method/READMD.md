# 类之间的关系图
```
                    +-----------------------+
                    |      Creator          |<>-----+
                    |-----------------------|       |
                    | + createProduct() : Product* |      
                    | + someOperation()     |       |
                    +-----------------------+       |
                              ^                     |
                              |                     |
               +--------------+--------------+      |
               |                             |      |
   +-------------------------+   +-------------------------+
   |   ConcreteCreatorA      |   |   ConcreteCreatorB      |
   |-------------------------|   |-------------------------|
   | + createProduct()       |   | + createProduct()       |
   +-------------------------+   +-------------------------+
                               
                      +-----------------------+
                      |      Product          |  
                      |-----------------------|  
                      | + use()               |  
                      +-----------------------+
                             ^         ^
                             |         |
             +---------------+         +---------------+
             |                                         |
  +-------------------------+             +-------------------------+
  |   ConcreteProductA      |             |   ConcreteProductB      |
  |-------------------------|             |-------------------------|
  | + use()                 |             | + use()                 |
  +-------------------------+             +-------------------------+
```
- Creator（抽象工厂） 定义了一个纯虚的工厂方法 createProduct()，以及一个使用产品的示例方法 someOperation()。
- ConcreteCreatorA/B（具体工厂） 分别继承自 Creator，重写 createProduct() 方法来创建具体的产品对象。
- Product（抽象产品） 定义了产品的接口，声明了纯虚函数 use()。
- ConcreteProductA/B（具体产品） 分别实现 Product 接口，提供各自的业务逻辑。

# 编译
```
g++ -std=c++17 -Wall -o factory_method factory_method.cpp
```

# 价值
工厂方法模式的实际应用价值主要体现在以下几个方面：

1. **降低耦合，提高灵活性**  
   通过将对象的创建封装在具体工厂中，客户端只需要依赖抽象接口而不关心具体产品的实现，从而减少了客户端与产品之间的耦合。这使得系统更容易维护和扩展。

2. **遵循开闭原则**  
   当需要增加新的产品时，只需新增一个具体工厂和对应的产品类，而不必修改已有的代码。这样能够在不破坏原有系统结构的前提下实现扩展。

3. **动态选择产品**  
   工厂方法模式允许在运行时根据不同的环境或配置动态决定创建哪个具体产品。比如在跨平台开发中，可以根据操作系统类型生成不同的界面控件；在日志系统中，可以根据配置返回不同类型的日志记录器。

4. **隐藏复杂的实例化过程**  
   如果产品对象的创建过程较为复杂或需要进行一定的预处理，工厂方法可以将这些细节封装起来，让客户端只关注产品的使用而无需关心创建细节。

### 应用实例举例

- **跨平台界面库**：  
  不同操作系统可能需要不同风格的窗口、按钮等控件。通过工厂方法，客户端只调用抽象的控件工厂，而具体的工厂则负责生成对应平台的控件实例，从而实现跨平台支持。

- **日志系统**：  
  根据配置文件或运行时条件，可以通过工厂方法创建文件日志、数据库日志或远程日志等不同类型的日志记录器，客户端只需要调用统一的日志接口即可。

总的来说，工厂方法模式使得对象创建和使用解耦，便于扩展和维护，是实现灵活、可扩展软件架构的一种有效手段。（citeturn0search0）